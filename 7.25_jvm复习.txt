1,jvm的组成
（类加载器+方法区+执行引擎+本地库接口）
运行时数据区（方法区和堆）
线程中含有的东西（java虚拟机栈+本地方法栈+程序计数器）-该区为线程私有
针对线程的运行时间（抢占式的调度运行）线程抢占cpu的时间片，线程计数器将存储下一次时间片抢占时运行的位置
2，java对于调用的理解（栈帧）
调用方法的时候会对应的创建一个栈的栈帧，方便进行程序的回调（先进先出）
栈（方法过多嵌套导致栈的深度过深（stackoverflow）
栈过多导致内存过高
本地方法栈描述的是native方法的运行（本地的底层语言）
3，类加载器（双亲委派机制）
java虚拟机加载文件为按需加载
当需要加载一个类，将请求传递给父类进行管理
类加载器的父子关系
子->父
自定义类加载器-》应用程序类加载器-》扩展类加载器-》启动类加载器
自定义类加载器
比如用网络加载Java类，为了保证传输中的安全性，采用了加密操作，那么以上3种加载器就无法加载这个类，这时候就需要自定义加载器
应用程序类加载器
加载环境变量和以及系统属性下的库，一般是一些第三方库（例如spring的类库）
扩展类加载器
进行加载java提供的类的加载器（例如一些数学函数，一些图像处理的方法）
启动类加载器
只加载核心内容（例如定义import的意义）
出于安全考虑，启动类只加载包名为：java、javax、sun开头的类
好处：
防止污染，确保核心的源代码不会被污染。
坏处：过于繁琐
===========
如何破坏双亲委派机制

反向委派机制

例子：JDBC 驱动加载
在 Java 中，JDBC（Java Database Connectivity）API 是一个典型的使用反向委派机制的例子。JDBC API 是由 Bootstrap 类加载器加载的，但具体的数据库驱动实现通常是由应用程序类加载器加载的。
====================================================
堆————垃圾回收的主要地方
垃圾回收的方法

可达性分析（如何定位垃圾）
（引用计数法，存在引用+1，引用失败-1，==0说明对象不存在引用）存在一堆垃圾循环引用的情况
（可达性分析。从根节点进行检查，能在堆中找到的对象标记为可达对象）
===========
垃圾回收算法
标记清除（存在内存碎片）
标记复制（浪费内存）
标记压缩
分代回收机制
老年代--年轻代
（jdk版本不同存在的设置不同）
1.7->1.8
存在改动
以下是jdk1.8中年轻代的分区
Eden：初次创建的对象都放在 Eden 区，也就是伊甸园区
Survivor 0：幸存者零区，在 Eden 区经历过一次炮火洗礼的精神小伙会进入之类
Survivor 1：在幸存者零区经历炮火洗礼的帅小伙会进入幸存者一区
（以下是堆的垃圾回收机制）
以下是触发条件
Minor GC 也称 Yong GC，因为其主要收集的内存区域就是新生代
Minor GC 的触发机制：Minor GC 的触发是被动的，当程序不断的创建新对象，JVM 会往 Eden 区塞，当 Eden 区内存空间满了的时候，就会触发 Minor GC，需要注意的是，Survivor 0 满不会触发 Minor GC

假设 Survivor 0 现在是满的，此时又触发了 Minor GC ，发现 Survivor 0 依旧是满的，存不下，此时会将 S0 区与Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 S1 区并且将S0区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将S0 区 和 S1区交换


老年代回收
以下是触发条件
Major GC 触发机制：当老年代空间不足时，会先尝试触发 Major GC，如果空间还是不足，则触发 full GC
Major GC 的速度比 Minor GC 慢十倍以上，STW 的时间会更长

STW（Stop-The-World）是指在垃圾回收过程中，JVM 会暂停所有应用程序线程的执行，以便进行垃圾回收操作。STW 时间越长，意味着应用程序暂停的时间越长，这可能会影响应用程序的响应速度和性能。

如果 Major GC 后，内存还是不足，就会触发 OOM（OutOfMemoryError）



