## 在MySQL中，事务的流程如下：

开启事务 ： 使用 START TRANSACTION 或 BEGIN 命令来显式地开启一个事务。 事务的开始会创建一个新的事务块，将所有的操作视为一个原子操作。
执行事务操作 ： 在事务块中，可以执行一系列的数据库操作，包括插入、更新、删除等。 这些操作可以是简单的单个语句，也可以是复杂的事务嵌套。
提交或回滚事务 ： 在执行完所有事务操作后，可以选择 COMMIT 命令来提交事务，将修改永久保存到数据库中。 如果在执行事务过程中发生了错误或触发了回滚条件，可以使用 ROLLBACK 命令来回滚事务，撤销所有对数据库的修改。
结束事务 ： 不管是提交还是回滚事务，都会结束当前事务块。 可以使用 END 命令或 COMMIT 命令来显式地结束事务。 如果不结束当前事务块，MySQL会默认为您自动提交事务。


## 全域锁（all）FTWRL
全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

既然备份数据库数据的时候，使用全局锁会影响业务，那有什么其他方式可以避免？ 有的，如果数据库的引擎支持的事务支持可重复读的隔离级别，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。 因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。


## 表级锁

需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。

再来说说元数据锁（MDL）。 我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL： 对一张表进行 CRUD 操作时，加的是 MDL 读锁； 对一张表做结构变更操作的时候，加的是 MDL 写锁；

意向锁
## 行级锁（x-独占锁，s-共享锁）（锁定读）
### update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)。

#### Record Lock，记录锁，也就是仅仅把一条记录锁上； （存在sx锁之分）


#### Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身； （防止在区间之内进行插入导致幻读）

间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的

#### Next-Key Lock（锁定的范围（】可以锁定范围以及保护数据）：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身（）

next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的

PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁
插入意向锁

## mysql怎样加行级锁

加锁的对象是索引，加锁的基本单位是 next-key lock，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。
