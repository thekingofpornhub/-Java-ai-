hashmap（线程不安全）和hashtable
==============================

hashmap（）存放kv的表
每个k对应的v是一个链表，在v链表对应的，当链表长度(阀值)超过 8 时且当前数组的长度 > 64时，将链表转换为红黑树（k大于64，v大于8）
插入数据：（put）
插入数据中如果插入的value与原先key的value相等，则进行覆盖
三个概念
容量（capacity）
是指当前map最多可以存放多少个元素，

大小 ( size )
是指当前map已经存放了多少个k-v键值对。

threshold 阈值
是扩容的阈值，当size超过阈值后，便需要对map进行扩容。也就是说，一般情况下，map当中的键值对数量不会达到其容量上限。阈值一般为：capacity*loadFactor(负载因子)
扩容机制
HashMap在进行扩容时使用 resize() 方法，计算 table 数组的新容量和 Node 在新数组中的新位置，将旧数组中的值复制到新数组中，从而实现自动扩容。因为每次扩容都是翻倍，与原来计算的 (n-1)&hash的结果相比，只是多了一个bit位，所以节点要么就在原来的位置，要么就被分配到"原位置+旧容量"这个位置。
为什么hashmap线程不安全
========================================================
扩容期间取出的值不准确
HashMap 本身默认的容量不是很大，如果不停地往 map 中添加新的数据，它便会在合适的时机进行扩容。而在扩容期间，它会新建一个新的空数组，并且用旧的项填充到这个新的数组中去。那么，在这个填充的过程中，如果有线程获取值，很可能会取到 null 值，而不是我们所希望的、原来添加的值。

同时 put 碰撞导致数据丢失
比如，有多个线程同时使用 put 来添加元素，而且恰好两个 put 的 key 是一样的，它们发生了碰撞，也就是根据 hash 值计算出来的 bucket 位置一样，并且两个线程又同时判断该位置是空的，可以写入，所以这两个线程的两个不同的 value 便会添加到数组的同一个位置，这样最终就只会保留一个数据，丢失一个数据。

可见性问题无法保证
可见性也是线程安全的一部分，如果某一个数据结构声称自己是线程安全的，那么它同样需要保证可见性，也就是说，当一个线程操作这个容器的时候，该操作需要对另外的线程都可见，也就是其他线程都能感知到本次操作。可是 HashMap 对此是做不到的，如果线程 1 给某个 key 放入了一个新值，那么线程 2 在获取对应的 key 的值的时候，它的可见性是无法保证的，也就是说线程 2 可能可以看到这一次的更改，但也有可能看不到。所以从可见性的角度出发，HashMap 同样是线程非安全的。

死循环造成 CPU 100%
下面我们再举一个死循环造成 CPU 100% 的例子。HashMap 有可能会发生死循环并且造成  CPU 100% ，这种情况发生最主要的原因就是在扩容的时候，也就是内部新建新的 HashMap 的时候，扩容的逻辑会反转散列桶中的节点顺序，当有多个线程同时进行扩容的时候，由于 HashMap 并非线程安全的，所以如果两个线程同时反转的话，便可能形成一个循环，并且这种循环是链表的循环，相当于 A 节点指向 B 节点，B 节点又指回到 A 节点，这样一来，在下一次想要获取该 key 所对应的 value 的时候，便会在遍历链表的时候发生永远无法遍历结束的情况，也就发生 CPU 100% 的情况。
========================================================
替代方案:
使用currenthashmap
ConcurrentHashMap是Java中提供的一个线程安全的HashMap实现，它采用分段锁和CAS（Compare and Swap）操作等技术来实现高并发和线程安全
虽然ConcurrentHashMap在并发环境下提供了很好的性能，但它也有一些局限性。首先，ConcurrentHashMap的所有操作都是线程安全的，但如果你需要执行复合操作（例如，先检查一个键是否存在，然后根据结果进行更新操作），那么就需要额外的同步措施来保证这些操作的原子性。因为在两个操作之间，可能有其他线程修改了ConcurrentHashMap的状态。
