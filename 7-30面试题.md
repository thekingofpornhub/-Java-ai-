### 1,泛型

E - Element (在集合中使用，因为集合中存放的是元素)
T - Type（Java 类）
K - Key（键）
V - Value（值）
N - Number（数值类型）
？ - 表示不确定的 java 类型

### 2，java中的类在内存中的存储
在Java中，对象在内存中的存储结构主要包括以下几个部分：

对象头（Header）：

Mark Word：存储对象的哈希码、GC分代年龄、锁状态标志等信息。

Class Pointer：指向对象的类元数据，JVM通过它来确定对象是哪个类的实例。

实例数据（Instance Data）：

存储对象的实际数据，包括类的字段（成员变量）。这些数据按照字段在类中声明的顺序进行排列。

对齐填充（Padding）：

为了保证对象的大小是8字节的倍数，可能会在对象的末尾添加一些填充字节。

当一个Java对象被创建时，它会被分配在堆内存中。堆是所有线程共享的一块内存区域，几乎所有的对象实例以及数组都在这里分配内存。

3，string不能被继承

在Java中，String类不能被继承。这是因为String类被声明为final12。final关键字表示该类不能被其他类继承，确保了String类的不可变性和安全性。

不可变性意味着一旦创建了一个String对象，它的值就不能被改变。这种设计有助于提高线程安全性和性能，因为多个线程可以安全地共享同一个String对象而不需要同步。

 ### String
  不可变性：String 是不可变的对象，一旦创建了一个 String 对象，它的值就不能被改变。
  
  线程安全：由于 String 是不可变的，所以它是线程安全的，可以在多个线程中安全地使用。
  
  性能：每次对 String 进行修改（如拼接、替换等）时，都会创建一个新的 String 对象，这可能会导致性能问题和内存浪费。
  
  ### 2. StringBuilder
  可变性：StringBuilder 是可变的对象，可以在不创建新对象的情况下修改其内容。
  
  非线程安全：StringBuilder 不是线程安全的，不进行同步处理，因此在单线程环境中使用时性能更好。
  
  性能：由于不需要考虑线程安全，StringBuilder 的操作通常比 StringBuffer 更快。
  
  ### 3. StringBuffer
  可变性：StringBuffer 也是可变的对象，可以在不创建新对象的情况下修改其内容。
  
  线程安全：StringBuffer 是线程安全的，通过同步机制实现，因此适用于多线程环境。
  
  性能：由于需要同步处理，StringBuffer 的操作通常比 StringBuilder 慢。

 StringBuffer 的线程安全性是通过同步机制实现的。具体来说，StringBuffer 的方法（如 append、insert 等）都使用了 
 
 synchronized 关键字，这意味着在多线程环境中，当一个线程调用这些方法时，其他线程会被阻塞，直到当前线程完成操作。

这种同步机制确保了多个线程在同时操作同一个 StringBuffer 对象时不会发生数据不一致的问题，但也因此会带来一定的性能开销。如果你在单线程环境中使用，建议使用 StringBuilder，因为它没有同步开销，性能更高。
java中字符串的拼接

+字符（循环中不推荐）

String.concat() 方法（也会进行创建新的，循环中不推荐）

### 4，new string和string a=abc

new是创建一个新的

接下来的是先在字符串池子中寻找，没有再进行创建。

### 5，==和equals（）

==（值是否相等）
equals（）（地址比较）

