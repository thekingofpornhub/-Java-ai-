synchronized关键字
java中的锁
偏向锁：
特点：当一个线程获取锁时，如果没有其他线程竞争，该锁会偏向于这个线程，减少获取锁的开销。
适用场景：适用于线程竞争较少的场景。
轻量级锁：
特点：当有其他线程竞争时，偏向锁会升级为轻量级锁，使用自旋锁来避免线程阻塞。
适用场景：适用于短时间内锁竞争不激烈的场景。
重量级锁：
特点：当锁竞争激烈时，轻量级锁会升级为重量级锁，线程会被阻塞，直到获取到锁。
适用场景：适用于高并发场景，确保线程安全。
ReentrantLock（可重入锁）：
特点：提供了更多的锁控制功能，如公平锁和非公平锁、可中断锁等。
适用场景：需要更灵活的锁控制时使用。
ReentrantReadWriteLock（读写锁）：
特点：分为读锁和写锁，读锁可以被多个线程同时持有，而写锁是独占的。
适用场景：读多写少的场景，提高并发性能。
StampedLock：
特点：提供了乐观读、悲观读和写锁三种模式，适合读多写少的场景。
适用场景：需要高性能读操作的场景。
synchronized：
特点：Java 内置的隐式锁，使用方便，但功能相对简单。
适用场景：简单的同步需求。
CAS（Compare-And-Swap）：
特点：一种无锁的并发机制，通过比较和交换操作来实现线程安全。
适用场景：高性能并发场景。
======================================
  java中锁升级的机制
  锁升级的具体过程
偏向锁升级为轻量级锁：
当一个线程持有偏向锁时，如果有其他线程尝试获取该锁，JVM 会撤销偏向锁，将其升级为轻量级锁。这个过程会导致短暂的“Stop The World”操作1。
轻量级锁升级为重量级锁：
如果轻量级锁的自旋等待失败，即多个线程竞争同一个锁且自旋次数超过一定阈值，锁会升级为重量级锁。此时，未获取到锁的线程会被阻塞，直到锁被释放2。
