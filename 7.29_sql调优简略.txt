1，sql调优（是DBA的活，哈哈哈）==（针对b+树节点大小进行优化）
max_length_for_sort_data`变量来决定使用哪种排序方式，这个优化也是DBA的活
=============================
1，索引的优化
查询能走索引就走索引
（优化的原则）
组建联合索引

最左匹配
其中包含了索引失效的情况（本质上还是筛选的条件导致b+树筛选出来的节点不再有序，优化器才选择进行回表查找）
数据量也会导致优化器的决策（数据过大）
explain判断一下事务的查询级别
2，事务内部减少锁的持有时间
事务内需要插入和修改（先插入后修改）
3，可重复读的间隙锁问题（RR）
RC一般为主流
4，数据过大走索引十分慢（删除旧数据）
删除的概率很低
5，数据量过大使用分库分表
将访问和数据量进行均摊，（分库的依据，userid）
id生成的方式（redis+雪花算法，mysql自增，redis自增）
雪花（时间戳+机器id+服务id+时间戳）
可以根据redis的集群进行设置机器码
6，分库分表的过程
双写（将增量数据向新表和旧表都进行书写）
将旧表的数据迁移到新库
检验新表和旧表的数据是否对的上
双读（流量均分与新旧表）
流量切换到新表
提前准备回滚机制
