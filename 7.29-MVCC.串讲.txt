1,怎么理解innodb中的mysql事务
事务-》使得一组操作要么全部成功，要么全部失败
2，事务的特性
  原子性，一致性，隔离性，持久性
原子性=事务在进行中不会存在完成一半的操作，要么全部成功，要么全部失败
  原子性由日志机制保证，事务开始的时候会创建一个事务日志，储存事务所作的修改记录到事务的日志中，如果事务完成，那么将日志异步刷新到磁盘中，如果事务失败，则根据undolog（回滚日志）进行回滚
undolog=现在所作事务的反操作，例子（insert-》delete）
一致性（防止脏读和幻读）
  innodb使用了mvcc（多版本并发机制来控制）
  mvcc利用版本号（事务id字段）（为每个事务创建了一个一致性视图）确保了并发事务在读取的一定读取的是该事务开始之前已经提交的快照（）
这么做的依据为可见性原则Read View
Read View 
维护的字段
m_ids(创建事务时其他未提交的活跃事务的id列表)
m_creator_ids(创建该事务的id)
m_low_limit_id(目前出现过的id+1)
m_up_limit_id（m_ids中最小的id，小于这个id的数据版本均可见）
遵循一个可见性原则，将要被修改的数据的 DB_TRX_ID 取出来，与系统当前其他活跃事务的 ID 去对比。
 DB_TRX_ID（当前id）
 DB_ROLL_PTR回滚指针
如果 DB_TRX_ID 跟 Read View 的属性做了某些比较，不符合可见性，那就通过 DB_ROLL_PTR 回滚指针去取出 Undo Log 中的 DB_TRX_ID 再比较。
即遍历链表的 DB_TRX_ID （从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的 DB_TRX_ID，那么这个 DB_TRX_ID 所在的记录就是当前事务能看见的最新老版本。
Read View（怎样判断这个事务究竟能不能看到快照）

隔离性（事务和事务之间存在着一定的隔离）
四个隔离级别（隔离级别越高的越安全，但是性能越低）（mysql的锁进行的实现）
持久性（）
redolog（重做日志）（mysql挂了也能复原）
在事务提交时，InnoDB会将事务日志中的修改操作先记录到redo log，然后异步刷新到磁盘。这样即使在系统崩溃的情况下，可以通过重放redo log来恢复到最后一次提交的状态，从而保证数据的持久性
3，四个隔离级别
  读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeatable Read）和串行化（Serializable）（由低到高）
RC：每次 SELECT 数据前都生成一个 ReadView。

RR：只在第一次读取数据时生成一个 ReadView，后面会复用第一次生成的。

串行化相当于不允许并发
实现这四个隔离级别是通过Read View实现的（读的快照是）
  
  命中索引了就对命中的节点进行加锁（行锁），未命中就对该表进行加锁（对整个b+树进行加锁）
  行锁的分类（读锁（共享，s锁）写锁（排他））
 
  
