1===需要进行确认的地方
1-》确保消息可以输入进路由（）
2-》确保消费者消化了消息（ack机制）
3-》定时重传机制（可以设置递增的时间以及递增的）
4-》防止rebbitmq挂了（持久化机制）
  就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。
2===rabbitmq怎样确保消息的有序性
  为了保证消息的顺序性，我们可以只使用一个消费者来接收业务消息（效率低）

  优先级队列
  在 RabbitMQ3.5 之后，当消费者数量较少，如果服务器检测到消费者不能及时消费消息的情况下，优先级队列就会生效
  具体有两种优先级策略：设置队列的优先级/设置消息的优先级
  当优先级队列消费生效时，会首先消费高优先级队列中的优先级高的消息，以此来实现顺序消费
死信队列
  RabbitMQ 里，当消息在队列中变成死信（消费者无法正常处理的消息）之后，它会被重新投递到一个交换机上（即死信交换机），死信交换机上绑定的消费队列就是死信队列。
  死信产生需要满足如下条件：
  消息被消费者手动拒绝接收，并且 requeue（重新加入队列）策略为 False
  消息已经过期（TTL）
  队列达到最大长度，消息装不下了
  当死信产生时，如果我们定义了一个死信交换机（其实就是一个普通的交换机，只是用于处理死信，所以叫死信交换机），然后在死信交换机上绑定了一个队列（称作死信队列）。
  最后，如果死信队列有消费者监听时，死信消息的处理就会和正常业务消息一样，从交换机到队列，再由死信消费者（监听死信队列的消费者）正常消费

异步消费（防止超卖）
  延时队列
RabbitMQ 本身不支持延时队列，但是我们可以通过 RabbitMQ 的插件 rabbitmq-delayed-message-exchange，或者使用 死信队列 + 消息过期 的方式来实现。

  应用场景
当我们在电商里购物，或者在 12306 买票时，大概都会遇到这样一个场景：每次下订单后，到支付订单中间有一段商品锁定时间，超过时间后未支付订单就会关闭。
